!!****if* source/Grid/GridSolvers/Multipole_experimental/gr_mpoleMom3Dcartesian
!!
!! NAME
!!
!!  gr_mpoleMom3Dcartesian
!!
!! SYNOPSIS
!!
!!  gr_mpoleMom3Dcartesian (integer, intent(in) :: idensvar)
!!
!! DESCRIPTION
!!
!!  Compute the multipole moments of the density distribution in
!!  three-dimensional cartesian geometry, assuming the center of mass
!!  and the total mass have first been computed.  On output, the
!!  Moment_R () and Moment_I () arrays contain the mass moments
!!  over the regular and irregular solid harmonics.
!!
!! ARGUMENTS
!!
!!  idensvar -- the index of the density variable
!!
!!***

!!REORDER(4): solnData

subroutine gr_mpoleMom3Dcartesian (idensvar)

  use Grid_data,         ONLY : gr_meshMe
  use Driver_interface,  ONLY : Driver_abortFlash
  use Logfile_interface, ONLY : Logfile_stamp
  use Grid_interface,    ONLY : Grid_getBlkPtr,          &
                                Grid_releaseBlkPtr,      &
                                Grid_getBlkBoundBox,     &
                                Grid_getDeltas,          &
                                Grid_getBlkIndexLimits
  use gr_mpoleData,      ONLY : symmetry_axis_3D,        &
                                zero,one,two,three,half, &
                                NumberInv,               &
                                n_cosine_moments,        &
                                dr_inv,                  &
                                dr_inner_zone_inv,       &
                                max_L,max_2L,            &
                                max_M,max_LM,max_Q,      &
                                max_radial_zones,        &
                                min_radial_zone,         &
                                ZONE_EXP,                &
                                ZONE_LOG,                &
                                zone_rmax,               &
                                zone_qmax,               &
                                zone_type,               &
                                zone_scalar_inv,         &
                                zone_lognorm_inv,        &
                                zone_exponent_inv,       &
                                inner_zone_rmax,         &
                                inner_zone_radii,        &
                                inner_zone_Qlower,       &
                                inner_zone_Qupper,       &
                                inner_zone_grid,         &
                                inner_zone_grid_inv,     &
                                outer_zone_Qshift,       &
                                X_centerofmass,          &
                                Y_centerofmass,          &
                                Z_centerofmass,          &
                                R_Moment,I_Moment,       &
                                Damping_R,Damping_I,     &
                                Moment_R,Moment_I,       &
                                blockCount,              &
                                blockList,bndBox,        &
                                blkLimits,blkLimitsGC,   &
                                delta
  use Simulation_data,   ONLY : sim_fluffDampCutoff

  implicit none
  
#include "constants.h"
#include "Flash.h"

  integer, intent(IN)  :: idensvar

  real    :: bndBox_i_low
  real    :: bndBox_j_low
  real    :: bndBox_k_low
  real    :: cell_mass
  real    :: cell_vol
  real    :: delta_i
  real    :: delta_j
  real    :: delta_k
  real    :: delta_i_half
  real    :: delta_j_half
  real    :: delta_k_half
  real    :: f,g,h
  real    :: I_c00,R_c00
  real    :: I_cLL,I_sLL,R_cLL,R_sLL
  real    :: R_damping,I_damping
  real    :: r_local
  real    :: rsqR,rinvI,rsqinvI,rscaled
  real    :: scl_inv,lgn_inv,exp_inv
  real    :: x,y,z,r
  real    :: xI,yI,zI,rI
  real    :: xR,yR,zR,rR

  real, pointer :: solnData (:,:,:,:)

  integer :: block_nr
  integer :: blockID
  integer :: c,s
  integer :: dr_unit
  integer :: i,j,k
  integer :: imax, jmax, kmax
  integer :: imin, jmin, kmin
  integer :: M,MM,L
  integer :: Q,Q_local,Q_lower,Q_upper
  integer :: type
  integer :: zone
!
!
!     ...Sum quantities over all locally held leaf blocks.
!
!
  Moment_R (:,1:max_Q) = zero
  Moment_I (:,1:max_Q) = zero

  do block_nr = 1,blockCount
     blockID = blockList (block_nr)

     call Grid_getBlkBoundBox     (blockID,  bndBox)
     call Grid_getDeltas          (blockID,  delta )
     call Grid_getBlkPtr          (blockID,  solnData)
     call Grid_getBlkIndexLimits  (blockID,  blkLimits, blkLimitsGC)

     imin         = blkLimits (LOW, IAXIS)
     jmin         = blkLimits (LOW, JAXIS)
     kmin         = blkLimits (LOW, KAXIS)  
     imax         = blkLimits (HIGH,IAXIS)
     jmax         = blkLimits (HIGH,JAXIS)
     kmax         = blkLimits (HIGH,KAXIS)
     delta_i      = delta (IAXIS)
     delta_j      = delta (JAXIS)
     delta_k      = delta (KAXIS)
     delta_i_half = delta_i * half
     delta_j_half = delta_j * half
     delta_k_half = delta_k * half
     bndBox_i_low = bndBox (LOW,IAXIS)
     bndBox_j_low = bndBox (LOW,JAXIS)
     bndBox_k_low = bndBox (LOW,KAXIS)
!
!
!
!          ...The 3D cartesian case. The full set of Moments for:
!
!                          0 =< L =< max_L
!                          0 =< M =< L       (cosine part)
!                          1 =< M =< L       (sine part)
!
!             are calculated and summed into the appropriate radial bins. Special
!             versions are supplied for the L = 0 and L = 1 cases to avoid many 'if'
!             inside the i,j,k loops.
!
!             If an axisymmetric symmetry has been specified, one enforces
!             computationally an axial symmetry on the problem, i.e. the problem
!             is treated as if axisymmetry is present (which in the real simulation
!             is never the case due to the finite resolution of the grid).
!             Axisymmetry means rotational invariance around the z-axis and hence
!             we evaluate only the M = 0 cosine components:
!
!                               0 =< L =< max_L
!                                    M = 0       (cosine part)
!
!
!
     cell_vol = delta_i * delta_j * delta_k

     if (max_L == 0) then
!
!
!        ...The spherical L = 0 case. No axisymmetric distinction necessary here!
!
!
         z = bndBox_k_low + delta_k_half - Z_centerofmass
         do k = kmin,kmax
            y = bndBox_j_low + delta_j_half - Y_centerofmass
            do j = jmin,jmax
               x = bndBox_i_low + delta_i_half - X_centerofmass
               do i = imin,imax

                  if (solnData(idensvar,i,j,k) .gt. sim_fluffDampCutoff) then !Added by JFG
                      cell_mass = solnData (idensvar,i,j,k) * cell_vol

                      r = sqrt (x * x + y * y + z * z)

                      if (r <= inner_zone_rmax) then
                          rscaled = r * dr_inner_zone_inv
                          dr_unit = int (ceiling (rscaled * inner_zone_grid_inv) * inner_zone_grid)
                          Q_lower = inner_zone_Qlower (dr_unit)
                          Q_upper = inner_zone_Qupper (dr_unit)

                          do Q = Q_lower,Q_upper
                             if (rscaled <= inner_zone_radii (Q)) exit
                          end do
                      else
                          do zone = min_radial_zone, max_radial_zones
                             if (r - zone_rmax (zone) <= zero) exit
                          end do

                          r_local = r - zone_rmax (zone - 1)
                          type    = zone_type         (zone)
                          scl_inv = zone_scalar_inv   (zone)
                          exp_inv = zone_exponent_inv (zone)

                          if (type == ZONE_EXP) then
                              Q_local = ceiling ( (r_local * scl_inv * dr_inv) ** exp_inv )
                          else if (type == ZONE_LOG) then
                              lgn_inv = zone_lognorm_inv (zone)
                              Q_local = ceiling ( exp_inv * log (r_local * scl_inv * dr_inv * lgn_inv + one) )
                          end if

                          Q = zone_qmax (zone - 1) + Q_local + outer_zone_Qshift
                      end if

                      Moment_R (1,Q) = Moment_R (1,Q) + cell_mass
                      Moment_I (1,Q) = Moment_I (1,Q) + cell_mass / (r * Damping_I (Q))
                  endif

                  x = x + delta_i
               end do
               y = y + delta_j
            end do
            z = z + delta_k
         end do

     else if (max_L == 1) then
!
!
!        ...The L = 1 case.
!
!
       if (symmetry_axis_3D)  then

         z = bndBox_k_low + delta_k_half - Z_centerofmass
         do k = kmin,kmax
            y = bndBox_j_low + delta_j_half - Y_centerofmass
            do j = jmin,jmax
               x = bndBox_i_low + delta_i_half - X_centerofmass
               do i = imin,imax

                  if (solnData(idensvar,i,j,k) .gt. sim_fluffDampCutoff) then !Added by JFG
                      cell_mass = solnData (idensvar,i,j,k) * cell_vol

                      r = sqrt (x * x + y * y + z * z)

                      if (r <= inner_zone_rmax) then
                          rscaled = r * dr_inner_zone_inv
                          dr_unit = int (ceiling (rscaled * inner_zone_grid_inv) * inner_zone_grid)
                          Q_lower = inner_zone_Qlower (dr_unit)
                          Q_upper = inner_zone_Qupper (dr_unit)

                          do Q = Q_lower,Q_upper
                             if (rscaled <= inner_zone_radii (Q)) exit
                          end do
                      else
                          do zone = min_radial_zone, max_radial_zones
                             if (r - zone_rmax (zone) <= zero) exit
                          end do

                          r_local = r - zone_rmax (zone - 1)
                          type    = zone_type         (zone)
                          scl_inv = zone_scalar_inv   (zone)
                          exp_inv = zone_exponent_inv (zone)

                          if (type == ZONE_EXP) then
                              Q_local = ceiling ( (r_local * scl_inv * dr_inv) ** exp_inv )
                          else if (type == ZONE_LOG) then
                              lgn_inv = zone_lognorm_inv (zone)
                              Q_local = ceiling ( exp_inv * log (r_local * scl_inv * dr_inv * lgn_inv + one) )
                          end if

                          Q = zone_qmax (zone - 1) + Q_local + outer_zone_Qshift
                      end if

                      R_damping = Damping_R (Q)
                      I_damping = Damping_I (Q)

                      rI = r * I_damping
                      rinvI = one / rI

                      R_c00 = cell_mass
                      I_c00 = cell_mass * rinvI

                      R_Moment (1) =   R_c00                                  ! cos 00
                      R_Moment (2) =   R_c00 * z * R_damping                  ! cos 10
                      I_Moment (1) =   I_c00                                  ! cos 00
                      I_Moment (2) =   I_c00 * z * I_damping * rinvI * rinvI  ! cos 10

                      Moment_R (:,Q) = Moment_R (:,Q) + R_Moment (:)
                      Moment_I (:,Q) = Moment_I (:,Q) + I_Moment (:)
                  endif

                  x = x + delta_i
               end do
               y = y + delta_j
            end do
            z = z + delta_k
         end do

       else

         z = bndBox_k_low + delta_k_half - Z_centerofmass
         do k = kmin,kmax
            y = bndBox_j_low + delta_j_half - Y_centerofmass
            do j = jmin,jmax
               x = bndBox_i_low + delta_i_half - X_centerofmass
               do i = imin,imax

                  if (solnData(idensvar,i,j,k) .gt. sim_fluffDampCutoff) then !Added by JFG
                      cell_mass = solnData (idensvar,i,j,k) * cell_vol

                      r = sqrt (x * x + y * y + z * z)

                      if (r <= inner_zone_rmax) then
                          rscaled = r * dr_inner_zone_inv
                          dr_unit = int (ceiling (rscaled * inner_zone_grid_inv) * inner_zone_grid)
                          Q_lower = inner_zone_Qlower (dr_unit)
                          Q_upper = inner_zone_Qupper (dr_unit)

                          do Q = Q_lower,Q_upper
                             if (rscaled <= inner_zone_radii (Q)) exit
                          end do
                      else
                          do zone = min_radial_zone, max_radial_zones
                             if (r - zone_rmax (zone) <= zero) exit
                          end do

                          r_local = r - zone_rmax (zone - 1)
                          type    = zone_type         (zone)
                          scl_inv = zone_scalar_inv   (zone)
                          exp_inv = zone_exponent_inv (zone)

                          if (type == ZONE_EXP) then
                              Q_local = ceiling ( (r_local * scl_inv * dr_inv) ** exp_inv )
                          else if (type == ZONE_LOG) then
                              lgn_inv = zone_lognorm_inv (zone)
                              Q_local = ceiling ( exp_inv * log (r_local * scl_inv * dr_inv * lgn_inv + one) )
                          end if

                          Q = zone_qmax (zone - 1) + Q_local + outer_zone_Qshift
                      end if

                      R_damping = Damping_R (Q)
                      I_damping = Damping_I (Q)

                      rI = r * I_damping
                      rinvI = one / rI
                      rsqinvI = rinvI * rinvI

                      R_c00 = cell_mass
                      I_c00 = cell_mass * rinvI

                      R_Moment (1) =   R_c00                               ! cos 00
                      R_Moment (2) =   R_c00 * z * R_damping               ! cos 10
                      R_Moment (3) = - R_c00 * x * R_damping * half        ! cos 11
                      R_Moment (4) = - R_c00 * y * R_damping * half        ! sin 11
                      I_Moment (1) =   I_c00                               ! cos 00
                      I_Moment (2) =   I_c00 * z * I_damping * rsqinvI     ! cos 10
                      I_Moment (3) = - I_c00 * x * I_damping * rsqinvI     ! cos 11
                      I_Moment (4) = - I_c00 * y * I_damping * rsqinvI     ! sin 11

                      Moment_R (:,Q) = Moment_R (:,Q) + R_Moment (:)
                      Moment_I (:,Q) = Moment_I (:,Q) + I_Moment (:)
                  endif

                  x = x + delta_i
               end do
               y = y + delta_j
            end do
            z = z + delta_k
         end do

       end if

     else
!
!
!        ...The general L >= 2 cases.
!
!
       if (symmetry_axis_3D) then

         z = bndBox_k_low + delta_k_half - Z_centerofmass
         do k = kmin,kmax
            y = bndBox_j_low + delta_j_half - Y_centerofmass
            do j = jmin,jmax
               x = bndBox_i_low + delta_i_half - X_centerofmass
               do i = imin,imax

                  if (solnData(idensvar,i,j,k) .gt. sim_fluffDampCutoff) then !Added by JFG
                      cell_mass = solnData (idensvar,i,j,k) * cell_vol

                      r = sqrt (x * x + y * y + z * z)

                      if (r <= inner_zone_rmax) then
                          rscaled = r * dr_inner_zone_inv
                          dr_unit = int (ceiling (rscaled * inner_zone_grid_inv) * inner_zone_grid)
                          Q_lower = inner_zone_Qlower (dr_unit)
                          Q_upper = inner_zone_Qupper (dr_unit)

                          do Q = Q_lower,Q_upper
                             if (rscaled <= inner_zone_radii (Q)) exit
                          end do
                      else
                          do zone = min_radial_zone, max_radial_zones
                             if (r - zone_rmax (zone) <= zero) exit
                          end do

                          r_local = r - zone_rmax (zone - 1)
                          type    = zone_type         (zone)
                          scl_inv = zone_scalar_inv   (zone)
                          exp_inv = zone_exponent_inv (zone)

                          if (type == ZONE_EXP) then
                              Q_local = ceiling ( (r_local * scl_inv * dr_inv) ** exp_inv )
                          else if (type == ZONE_LOG) then
                              lgn_inv = zone_lognorm_inv (zone)
                              Q_local = ceiling ( exp_inv * log (r_local * scl_inv * dr_inv * lgn_inv + one) )
                          end if

                          Q = zone_qmax (zone - 1) + Q_local + outer_zone_Qshift
                      end if

                      R_damping = Damping_R (Q)
                      I_damping = Damping_I (Q)

                      zR = z * R_damping
                      rR = r * R_damping
                      zI = z * I_damping
                      rI = r * I_damping
                      rsqR = rR * rR
                      rinvI = one / rI
                      rsqinvI = rinvI * rinvI

                      R_c00 = cell_mass
                      I_c00 = cell_mass * rinvI

                      R_Moment (1) = R_c00                      ! cos 00
                      R_Moment (2) = R_c00 * zR                 ! cos 10
                      I_Moment (1) = I_c00                      ! cos 00
                      I_Moment (2) = I_c00 * zI * rsqinvI       ! cos 10

                      do L = 2,max_L                            ! cos L0
                         h = real (L + L - 1)
                         g = real ((L - 1) * (L - 1))
                         f = NumberInv (L) * NumberInv (L)
                         R_Moment (L+1) = (h * zR * R_Moment (L) - rsqR * R_Moment (L-1)) * f
                         I_Moment (L+1) = (h * zI * I_Moment (L) -    g * I_Moment (L-1)) * rsqinvI
                      end do

                      Moment_R (:,Q) = Moment_R (:,Q) + R_Moment (:)
                      Moment_I (:,Q) = Moment_I (:,Q) + I_Moment (:)
                  endif

                  x = x + delta_i
               end do
               y = y + delta_j
            end do
            z = z + delta_k
         end do

       else

         z = bndBox_k_low + delta_k_half - Z_centerofmass
         do k = kmin,kmax
            y = bndBox_j_low + delta_j_half - Y_centerofmass
            do j = jmin,jmax
               x = bndBox_i_low + delta_i_half - X_centerofmass
               do i = imin,imax

                  if (solnData(idensvar,i,j,k) .gt. sim_fluffDampCutoff) then !Added by JFG
                      cell_mass = solnData (idensvar,i,j,k) * cell_vol

                      r = sqrt (x * x + y * y + z * z)

                      if (r <= inner_zone_rmax) then
                          rscaled = r * dr_inner_zone_inv
                          dr_unit = int (ceiling (rscaled * inner_zone_grid_inv) * inner_zone_grid)
                          Q_lower = inner_zone_Qlower (dr_unit)
                          Q_upper = inner_zone_Qupper (dr_unit)

                          do Q = Q_lower,Q_upper
                             if (rscaled <= inner_zone_radii (Q)) exit
                          end do
                      else
                          do zone = min_radial_zone, max_radial_zones
                             if (r - zone_rmax (zone) <= zero) exit
                          end do

                          r_local = r - zone_rmax (zone - 1)
                          type    = zone_type         (zone)
                          scl_inv = zone_scalar_inv   (zone)
                          exp_inv = zone_exponent_inv (zone)

                          if (type == ZONE_EXP) then
                              Q_local = ceiling ( (r_local * scl_inv * dr_inv) ** exp_inv )
                          else if (type == ZONE_LOG) then
                              lgn_inv = zone_lognorm_inv (zone)
                              Q_local = ceiling ( exp_inv * log (r_local * scl_inv * dr_inv * lgn_inv + one) )
                          end if

                          Q = zone_qmax (zone - 1) + Q_local + outer_zone_Qshift
                      end if

                      R_damping = Damping_R (Q)
                      I_damping = Damping_I (Q)

                      xR = x * R_damping
                      yR = y * R_damping
                      zR = z * R_damping
                      rR = r * R_damping
                      xI = x * I_damping
                      yI = y * I_damping
                      zI = z * I_damping
                      rI = r * I_damping
                      rsqR = rR * rR
                      rinvI = one / rI
                      rsqinvI = rinvI * rinvI

                      R_c00 = cell_mass
                      I_c00 = cell_mass * rinvI

                      R_Moment (1) = R_c00                       ! cos 00
                      R_Moment (2) = R_c00 * zR                  ! cos 10
                      I_Moment (1) = I_c00                       ! cos 00
                      I_Moment (2) = I_c00 * zI * rsqinvI        ! cos 10

                      do L = 2,max_L                             ! cos L0
                         h = real (L + L - 1)
                         g = real ((L - 1) * (L - 1))
                         f = NumberInv (L) * NumberInv (L)
                         R_Moment (L+1) = (h * zR * R_Moment (L) - rsqR * R_Moment (L-1)) * f
                         I_Moment (L+1) = (h * zI * I_Moment (L) -    g * I_Moment (L-1)) * rsqinvI
                      end do

                      c = max_L + 2
                      s = n_cosine_moments + 1

                      R_Moment (c) = - R_c00 * xR * half                ! cos 11
                      R_Moment (s) = - R_c00 * yR * half                ! sin 11
                      I_Moment (c) = - I_c00 * xI * rsqinvI             ! cos 11
                      I_Moment (s) = - I_c00 * yI * rsqinvI             ! sin 11

                      R_cLL = R_Moment (c)                              ! store 11 for 22 case (avoid cache miss)
                      R_sLL = R_Moment (s)                              ! store 11 for 22 case
                      I_cLL = I_Moment (c)                              ! store 11 for 22 case
                      I_sLL = I_Moment (s)                              ! store 11 for 22 case

                      R_Moment (c+1) =         zR * R_cLL               ! cos 21
                      R_Moment (s+1) =         zR * R_sLL               ! sin 21
                      I_Moment (c+1) = three * zI * I_cLL * rsqinvI     ! cos 21
                      I_Moment (s+1) = three * zI * I_sLL * rsqinvI     ! sin 21

                      do L = 2,max_L-1                                  ! M=1,L=3,max_L (shifted L-loop!)
                         h = real (L + L + 1)
                         g = real ((L + 1) * (L - 1))
                         f = NumberInv (L + 2) * NumberInv (L)
                         R_Moment (c+L) = (h * zR * R_Moment (c+L-1) - rsqR * R_Moment (c+L-2)) * f
                         R_Moment (s+L) = (h * zR * R_Moment (s+L-1) - rsqR * R_Moment (s+L-2)) * f
                         I_Moment (c+L) = (h * zI * I_Moment (c+L-1) -    g * I_Moment (c+L-2)) * rsqinvI
                         I_Moment (s+L) = (h * zI * I_Moment (s+L-1) -    g * I_Moment (s+L-2)) * rsqinvI
                      end do

                      c = c + max_L
                      s = s + max_L

                      do M = 2,max_L-1                                              ! M=2,max_L-1 cases
                         MM = M + M
                         h = real (MM + 1)
                         g = real (MM - 1)
                         f = NumberInv (MM)

                         R_Moment (c) =       (yR * R_sLL - xR * R_cLL) * f         ! cos MM
                         R_Moment (s) =     - (yR * R_cLL + xR * R_sLL) * f         ! sin MM
                         I_Moment (c) =   g * (yI * I_sLL - xI * I_cLL) * rsqinvI   ! cos MM
                         I_Moment (s) = - g * (yI * I_cLL + xI * I_sLL) * rsqinvI   ! sin MM

                         R_cLL = R_Moment (c)                                       ! store MM for M+1,M+1
                         R_sLL = R_Moment (s)                                       ! store MM for M+1,M+1
                         I_cLL = I_Moment (c)                                       ! store MM for M+1,M+1
                         I_sLL = I_Moment (s)                                       ! store MM for M+1,M+1

                         R_Moment (c+1) =     zR * R_cLL                            ! cos L=M+1,M
                         R_Moment (s+1) =     zR * R_sLL                            ! sin L=M+1,M
                         I_Moment (c+1) = h * zI * I_cLL * rsqinvI                  ! cos L=M+1,M
                         I_Moment (s+1) = h * zI * I_sLL * rsqinvI                  ! sin L=M+1,M

                         do L = 2,max_L-M                                           ! L=M+2,max_L (shifted L-loop!)
                            h = real (L + L + MM - 1)
                            g = real (L + MM - 1) * (L - 1)
                            f = NumberInv (L + MM) * NumberInv (L)
                            R_Moment (c+L) = (h * zR * R_Moment (c+L-1) - rsqR * R_Moment (c+L-2)) * f
                            R_Moment (s+L) = (h * zR * R_Moment (s+L-1) - rsqR * R_Moment (s+L-2)) * f
                            I_Moment (c+L) = (h * zI * I_Moment (c+L-1) -    g * I_Moment (c+L-2)) * rsqinvI
                            I_Moment (s+L) = (h * zI * I_Moment (s+L-1) -    g * I_Moment (s+L-2)) * rsqinvI
                         end do

                         c = c + max_L - M + 1
                         s = s + max_L - M + 1

                      end do

                      g = real (max_2L - 1)
                      f = NumberInv (max_2L)

                      R_Moment (c) =       (yR * R_sLL - xR * R_cLL) * f            ! cos  max_L,max_L
                      R_Moment (s) =     - (yR * R_cLL + xR * R_sLL) * f            ! sin  max_L,max_L
                      I_Moment (c) =   g * (yI * I_sLL - xI * I_cLL) * rsqinvI      ! cos  max_L,max_L
                      I_Moment (s) = - g * (yI * I_cLL + xI * I_sLL) * rsqinvI      ! sin  max_L,max_L

                      Moment_R (:,Q) = Moment_R (:,Q) + R_Moment (:)
                      Moment_I (:,Q) = Moment_I (:,Q) + I_Moment (:)
                  endif

                  x = x + delta_i
               end do
               y = y + delta_j
            end do
            z = z + delta_k
         end do

       end if

     end if
!
!
!    ...Get ready for retrieving next LEAF block for the current processor.
!
!
     call Grid_releaseBlkPtr (blockID, solnData)

  end do
!
!
!    ...Up to now we only added the contribution of each cell to its particular
!       radial bin. Each cell should contribute its regular moment to all cells
!       with radius greater than it and its irregular moment to all cells with
!       radius less than it. This is handled in the next routine, which also
!       will give all processors a copy of the final moments.
!
!
  call gr_mpoleCollectMoments ()
!
!
!    ...Ready!
!
!
  return
end subroutine gr_mpoleMom3Dcartesian
